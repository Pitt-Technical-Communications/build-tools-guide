<!DOCTYPE html>
<html lang="en">
<head>
<title>page title</title>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" type="text/css" href="style.css">
</head>


<body>
<div class="header">
  <h1>Guide to C/C++ Build Tools</h1>
  <p>Other Tools</p>
</div>

<section>

<table>
<tr>
<td>
<nav>
  <ul>
      <li><a href="index.html">About This Guide</a></li>
      <li><a href="what-are-build-tools.html">What Are Build Tools?</a></li>
      <li><a href="setup.html">Setting Up</a></li>
      <li><a href="compilers.html">Compilers</a></li>
      <li><a href="makefiles.html">Makefiles</a></li>
      <li><a href="cmake.html">CMake</a></li>
      <li><a href="misc.html">Other Tools</a></li>
      <li><a href="conclusion.html">Next Steps</a></li>
  </ul>
</nav>
</td>
<td>
<article>
<h2>Debuggers</h2>
  <p>Debuggers are essential tools for effective programming, especially in low-level languages like C and C++. Debugging tools help you figure out where bugs and issues are in your program without having to use print statements. In this section, we'll be covering two prominent tools for command-line debugging: <i>GDB</i> and <i>Valgrind</i>.</p>
<h2>GDB</h2>
  <p>GDB (from GNU Debugger) is the GNU toolchain's dedicated debugger. GDB is most useful for tracking the execution of a program. It uses a system called <i>ptrace</i> to trace the execution of code, allowing you to change a process's memory and register while it's running.</p>
<h3>Basics of GDB</h3>
  <p>To get started, we'll examine some sample code for a basic Linked List that stores English words. We'll write code in small portions and use GDB to debug it as we go. We'll start with a simple method to create a new linked_list and we'll test that it works in main.</p>
  <pre>
<code>typdef struct ll_node {
  struct ll_node* next;
  char* word;
} ll_node;

typedef struct linked_list {
  ll_node* head;
} word_list;

linked_list* new_ll() {
  linked_list* ll = malloc(sizeof(linked_list));
  if (ll = NULL) return NULL;
  ll->head = NULL;
  return ll;
}

int main() {
  linked_list* words = new_ll();
}</code>
</pre>
<h3>Starting GDB</h3>
<p>We use the <code>-g</code> flag when compiling, which tells the compiler to generate and retain debugging information in the executable. Then, we open the executable in gdb and use the command <code>r</code> to run it.</p>
<pre>
<samp>$ gcc ll.c -g -o ll
$ gdb ll
(gdb) r

Program received signal SIGSEGV, Segmentation fault.
0x000055555555517d in new_ll () at ll.c:16
16		ll->head = NULL;</samp>
</pre>
<p>We get a segmentation fault error at line 16, which occurs when we try to access memory that we don't have access to. As <code>ll->head</code> is the only memory we try to access in this line, it's likely that <code>ll</code> points to the wrong place.</p>
<h3>Breakpoints and Variables</h3>
<p>To find where our code goes wrong, we can use breakpoints to view variables at various points in execution. We can start by using the <code>l</code> command, for list, to view the line numbers of our code. <code>l</code> will display the next 10 lines, while <code>l -</code> will display the previous 10. We'll check that malloc successfully allocated memory for our linked list structure by placing a breakpoint on line 14 with the <code>b</code> command and printing the value of <code>ll</code>.<p>
<pre><samp>(gdb) b 14
Breakpoint 2 at 0x555555555155: file ll.c, line 14.
(gdb) r
The program being debugged has been started already.
Start it from the beginning? (y or n) y

Breakpoint 2, new_ll () at ll.c:14
14		linked_list* ll = malloc(sizeof(linked_list));
(gdb) p ll
$1 = (linked_list *) 0x5555555551b0 <__libc_csu_init></samp></pre>
<p>This tells use that <code>ll</code> has the value <code>0x5555555551b0</code>, which is a valid memory address. Place another breakpoint at line 16, where our error occurs and check its value there. Then, use the <code>c</code> command to continue execution.</p>
<pre><samp>(gdb) b 16
Breakpoint 2 at 0x555555555179: file ll.c, line 16.
(gdb) c
Continuing.

Breakpoint 2, new_ll () at ll.c:16
16		ll->head = NULL;
(gdb) p ll
$2 = (linked_list *) 0x0</samp></pre>
<p>At this point, we see that <code>ll</code> has the value <code>0x0</code>, which is <code>NULL</code>.</p>
</td>
</tr>
</table>
</section>
</body>
</html>
